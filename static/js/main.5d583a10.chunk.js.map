{"version":3,"sources":["Header/Header.style.js","Header/Header.js","Body/Body.style.js","Body/Body.js","Sorting/Timer.js","Sorting/TimerScale.js","Sorting/SortValidation.js","Sorting/Bubble.js","Sorting/Merge.js","Sorting/Quick.js","Sorting/Heap.js","App.js","index.js"],"names":["Container","styled","div","ButtonLabel","p","props","disableColor","Button","button","SliderContainer","valuetext","value","Header","ControlSliderState","getSliderState","setArrayState","getArrayState","bubbleSort","MergeSort","QuickSort","HeapSort","setIndex","setFollowingIndex","setDisable","getDisableValue","className","disabled","onClick","sliderState","newArray","i","randomInteger","CreateNewArray","Slider","defaultValue","onChange","e","getAriaValueText","aria-labelledby","valueLabelDisplay","step","marks","min","max","Bar","height","change","BarLabel","Body","data","getIndex","getFollowingIndex","map","size","idx","style","backgroundColor","length","sleep","milliseconds","Promise","resolve","setTimeout","timerScale","sliderValue","timerInput","sortValidation","array","a","bubbleArray","console","log","len","j","tmp","newBubbleArray","slice","alert","merge","left","right","leftLimit","rightLimit","sorted","buffer","mergeSort","arr","Array","from","n","leftStart","Math","temp","mergeArray","newMergeArray","swap","partition","low","high","q","newQuickArray","quickSort","pivot","heapSort","floor","heapify","newHeapArray","random","App","useState","setRandomArray","activeIndex","setActiveIndex","nextIndex","setNextIndex","disableOptions","setBool","useEffect","generatedArray","newGeneration","index","boolean","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.5d583a10.chunk.js","sourcesContent":["/*Using the style components extension to introduce some css \nproperties for certain components*/\nimport styled from 'styled-components';\n\n\n/*Each of the style sets correlate to the CONTAINER OR HEADER\nfor example or some general in-depth styling that can be abstracted */\n\n/* \npadding : top, right, bottom and left in this order \n*/\nexport const Container = styled.div `\n\n    height: 100px;\n    width: 100%;\n    background-color: black; \n    align-content:center;\n    display:flex; \n    flex-direction: row;\n    justify-content:space-around;\n\n`;\n\n\nexport const ButtonLabel = styled.p `\n\n    Color:${ (props) => props.disableColor ? \"#ff1100\" : \"white\" };\n    font-size:120%; \n    padding-bottom:10px;\n    text-align:center;\n    disabled:\n \n\n`;\n\nexport const Button = styled.button `\n\n    Color:${ (props) => props.disableColor ? \"#ff1100\" : \"white\"  };\n    font-size:120%;\n    border:none;\n    background:none;\n\n`;\n\nexport const SliderContainer = styled.div `\n\n    width: 15%;\n    padding-top: 1%;\n    display: inline-block;\n\n`;","import React from 'react'; \nimport '../css/index.css'\nimport '../css/App.css'; \nimport Slider from '@material-ui/core/Slider'; \nimport { Button, Container, ButtonLabel, SliderContainer } from './Header.style'; \nimport { randomInteger } from '../App';\n\n\n/*STATE FORMAT [ NAME OF THE STATE, VALUE ] */\nfunction valuetext(value) { \n    return `${value}`;\n    \n}\n\n\nexport default function Header(\n    \n    { ControlSliderState, getSliderState, setArrayState, getArrayState, bubbleSort, MergeSort, QuickSort, HeapSort, \n      setIndex,setFollowingIndex,setDisable, getDisableValue }\n    \n) { \n    \n    /*This function will be used to replace the current array with \n    randomly generated numbers*/ \n    function CreateNewArray() { \n\n        const sliderState = getSliderState(); \n        const newArray = [sliderState]; \n        for ( let i = 0; i < sliderState; i++) {\n            newArray[i] = randomInteger(40, 850); \n        }\n        setArrayState(newArray); \n\n    }\n\n    return ( \n\n        <div>\n        \n    {/*This is the header of the application*/}\n     <Container>\n\n                    \n        {/*The various buttons to be placed within the header*/}\n                <Button className=\"Button\"\n                    disabled={getDisableValue()}\n                    disableColor={getDisableValue()}\n                    onClick={() => {\n                    \n                    /*Generate an array which is the same size as the current slider state*/\n                    CreateNewArray();\n                   \n                    \n        }}> Create New Array </Button>\n\n\n           <SliderContainer>\n           \n                    {/*This is the button label replaced the typography*/}\n                    <ButtonLabel\n                     disableColor={getDisableValue()}  \n                    >\n                         Select The Array Size And Speed\n                    </ButtonLabel> \n          \n                    <Slider \n                        \n               defaultValue={15}\n               onChange={(e,value) => {\n                   ControlSliderState(value); \n               }}\n               getAriaValueText={valuetext}\n               aria-labelledby=\"discrete-slider\"\n               valueLabelDisplay=\"auto\"\n               step={15}\n               marks={true}\n               min={15}\n               max={145}\n               disabled={getDisableValue()}\n\n               />\n               </SliderContainer> \n\n           {/*Different buttons */}\n                <Button className=\"Button\"\n                    disabled={getDisableValue()}\n                    disableColor={getDisableValue()}\n                    onClick={() => {\n                \n                    MergeSort(getArrayState, setArrayState, setIndex, \n                        setFollowingIndex, setDisable); \n                    }}> Merge Sort</Button> \n                \n                <Button className=\"Button\"\n                    disabled={getDisableValue()}\n                    disableColor={getDisableValue()}\n                    onClick={() => {\n\n                    QuickSort(getArrayState, setArrayState, setIndex,\n                        setFollowingIndex, setDisable); \n                        \n                    }}> Quick Sort </Button> \n               \n                <Button className=\"Button\"\n                    disabled={getDisableValue()}\n                    disableColor={getDisableValue()}\n\n                    onClick={ () => {\n\n                    HeapSort(getArrayState, setArrayState, setIndex, \n                        setFollowingIndex, setDisable); \n\n                    }}> Heap Sort </Button>\n                \n                <Button className=\"Button\"\n                    disabled={getDisableValue()}\n                    disableColor={getDisableValue()}    \n                    onClick={() => {\n                    bubbleSort(getArrayState, setArrayState, setIndex,\n                        setFollowingIndex, setDisable); \n                }}> Bubble Sort</Button> \n\n               \n       \n       </Container>\n       \n   \n   </ div> \n\n    ); \n\n}\n\n\n\n\n","import styled from 'styled-components';\n\n/*\nprops.change refers to the prop \"change\" being called when \nthe bar element is mapped too in Body.js \n\n\n\n*/\nexport const Bar = styled.div `\n\n    width:4%; \n    background-color: black;\n    height:${(props) => props.height}; \n    background-color: ${ (props) => props.change ? \"#eb4034\" : \"#a29b99\" };\n    margin-left:5px;\n    \n`;\n\nexport const BarLabel = styled.p ` \n\n    font-size:100%; \n    font-weight:600;\n    Color:black; \n    text-align:center;\n    padding-top:10px;\n`;\n\n\nexport const Container = styled.div `\n\n    display:flex;\n    flex-direction:row; \n    justify-content:center;\n    width: 78%; \n    margin-left:11%;\n\n`;","import '../css/index.css';\nimport '../css/App.css';  \nimport { Container, Bar, BarLabel} from './Body.style';\n\n\n\n//This function will take the array from the app.js file as its parameter \nexport default function Body({data, getIndex, getFollowingIndex }) {  \n\n  \n    return (\n\n        <Container>\n            \n            {/*We need to map the array for the bars in the div\n            where size is how each element within is accessed  */}\n            {\n\n            \n                data.map((size, idx) => (\n                  \n                    <Bar\n                        /*originally had 270 */\n                        height={`${size}px`}\n                        key={idx}\n                        change={getIndex() === idx}\n                        style={getFollowingIndex() === idx ? { backgroundColor: \"#008000\" } : null}\n                       \n                    >\n                        \n                    {/*We want to display the number only if the the size is less than or = to 45\n                    based on the steps from the slider that are present*/}\n                        \n                        {data.length <= 45 && < BarLabel > {size}</BarLabel>}\n                    \n                    </Bar>\n\n                    \n                ))\n\n            }\n\n        </Container>\n\n    )\n\n\n}\n\n","/*This function will return a promise that will be resolved \nwithin a certain number being milliseconds*/\nexport const sleep = (milliseconds) => {\n    return new Promise(resolve => setTimeout(resolve, milliseconds));\n}","/*This function will scale the timer based on the slider  */\nexport default function timerScale ( sliderValue, timerInput ) { \n\n    //Ex; 200 input; output = 100, etc... for 30 and 50 for 100 input \n    if ( sliderValue === 30 ) { \n\n        return timerInput = timerInput / 2; \n\n    } else if ( sliderValue >= 45 ) { \n\n        return timerInput = timerInput / 4;  \n    } \n\n    return timerInput;\n\n}","/*This function will check if the array given as param is sorted or not   */\nexport default function sortValidation(array) {\n\n    //Iterate and check each of the pairs in the array\n    for (let i = 0; i < array.length - 1; i++) {\n        if (array[i] > array[i + 1]) {\n            return false;\n        }\n\n    }\n\n    return true;\n\n\n};","import {sleep} from './Timer';\nimport timerScale from './TimerScale';\nimport sortValidation from './SortValidation';\n\nexport default async function bubbleSort(\n\n    getArrayState, setArrayState, setIndex, setFollowingIndex, setDisable) {\n\n\n    let bubbleArray = getArrayState();\n    console.log(sortValidation(bubbleArray));\n\n    //If the array is not sorted we will continue here\n    if (sortValidation(bubbleArray) === false) {\n\n        let len = bubbleArray.length;\n\n\n        /*With the first for loop we are intending to \n        bubble one element to the end of the array \n        */\n        setDisable(true);\n\n        for (let i = 0; i < len; i++) {\n\n            if (sortValidation(bubbleArray) === true) {\n                break;\n            }\n\n            let j;\n\n            //The second for loop will then compare that element with the next \n            for (j = 0; j < len; j++) {\n\n                //Swap the elements accordingly\n                if (bubbleArray[j] > bubbleArray[j + 1]) {\n\n                    /*\n                        At first the greater element is red \n                        and then the smaller element is green\n                        but since they are swapped this will switch itself\n                    */\n\n                    //Await a scaled sleep timer for the bubble sort\n                    await sleep(timerScale(getArrayState().length, 200));\n\n                    setIndex(j);\n                    setFollowingIndex(j + 1);\n\n                    await sleep(timerScale(getArrayState().length, 200));\n\n                    let tmp = bubbleArray[j];\n                    bubbleArray[j] = bubbleArray[j + 1];\n                    bubbleArray[j + 1] = tmp;\n\n                    /*We need to update the state after each swap */\n                    const newBubbleArray = bubbleArray.slice(0);\n                    setArrayState(newBubbleArray);\n\n                } else { //in the case that the first element is smaller\n\n                    setIndex(j); //This will continue tracking to show the visual process\n\n                }\n\n                await sleep(timerScale(getArrayState().length, 100));\n\n            }\n\n        }\n\n        //set the current indices to null to remove colour\n        setIndex(null);\n        setFollowingIndex(null);\n\n        //Set the state for the final array just in case\n        const newBubbleArray = bubbleArray.slice(0);\n        setArrayState(newBubbleArray);\n\n        //Allow other buttons to be accessed again\n        setDisable(false);\n\n    } else {\n        alert(\"Please Generate a new Array\\n as current is sorted\");\n    }\n\n\n};","import {sleep} from './Timer';\nimport timerScale from './TimerScale';\nimport sortValidation from './SortValidation';\n\n\n//This function will merge the arrays\nconst merge = async (left, right, leftLimit, rightLimit, sorted, buffer, setIndex, setFollowingIndex) => {\n\n  let i = left;\n\n  //Compare the two sub arrays and merge them in the sorted order\n  while (left < leftLimit && right < rightLimit) {\n\n    //Allows us to see the different sections that are being partioned \n    setIndex(left);\n    setFollowingIndex(right);\n\n    if (sorted[left] <= sorted[right]) {\n\n      buffer[i++] = sorted[left++];\n    } else {\n      buffer[i++] = sorted[right++];\n    }\n  }\n\n  //Sleep to show colour progression here\n  await sleep(timerScale(sorted.length, 400));\n\n\n  //If there are elements in the left sub arrray then add it to the result\n  while (left < leftLimit) {\n    buffer[i++] = sorted[left++];\n  }\n\n  //If there are elements in the right sub array then add it to the result\n  while (right < rightLimit) {\n    buffer[i++] = sorted[right++];\n  }\n\n}\n\nconst mergeSort = async (arr, setIndex, setFollowingIndex, setArrayState) => {\n\n\n  //Create two arrays for sorting\n  let sorted = Array.from(arr);\n  let n = sorted.length;\n  let buffer = new Array(n);\n\n  /*\n\n  The first for loop will iterate for the whole array giving a bounds \n  for the second array which works bottom to top solution. \n\n  Non recursive solution : Hence the reason we start bottom up\n\n  */\n  for (let size = 1; size < n; size *= 2) {\n    for (let leftStart = 0; leftStart < n; leftStart += 2 * size) {\n\n      //Get the two sub arrays\n      let left = leftStart,\n        right = Math.min(left + size, n),\n        leftLimit = right,\n        rightLimit = Math.min(right + size, n);\n\n      //Merge the sub arrays\n      await merge(left, right, leftLimit, rightLimit, sorted, buffer, setIndex, setFollowingIndex);\n    }\n\n    //Swap the sorted sub array and merge them\n    let temp = sorted;\n    sorted = buffer;\n    buffer = temp;\n\n\n    //Certain portion will be sorted at this point \n    const newBubbleArray = sorted.slice(0);\n    setArrayState(newBubbleArray);\n\n\n  }\n\n  return sorted;\n}\n\n\n\nexport default async function MergeSort(\n\n  getArrayState, setArrayState, setIndex, setFollowingIndex, setDisable\n\n) {\n\n  let mergeArray = getArrayState();\n  if (sortValidation(mergeArray) === false) {\n\n    //Disable the use of buttons here \n    setDisable(true);\n\n    const newMergeArray = await mergeSort(mergeArray, setIndex, setFollowingIndex, setArrayState);\n    setArrayState(newMergeArray);\n\n    //Remove any colours left over\n    setIndex(null);\n    setFollowingIndex(null);\n\n    //Allow buttons to be pressed again\n    setDisable(false);\n\n  } else { \n    alert(\"Please Generate a new Array\\n as current is sorted\");\n  }\n\n\n\n}","import {sleep} from './Timer';\nimport timerScale from './TimerScale';\nimport sortValidation from './SortValidation';\n\n\n\n/*\n    Within quicksort pivot is picked and everything within the\n    array that is less than the pivot is sorted to the left \n    and greater to the right of hte pivot \n\n    then more pivots are picked and this continues for \n    each half. The left hand side is then sorted \n\n\n\n*/\n\n/* This function will swap elements at certain indices of given array*/\nlet swap = async (arr, i, j) => {\n\n    await sleep(timerScale(arr.length, 200));\n\n\n    let tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n\n    //await sleep(timerScale(arr.length, 200));\n};\n\n\n/* This function creates a partition for us \nand will create a pivot point for the quick sort*/\n\nlet partition = async (arr, low, high, setIndex, setFollowingIndex, setArrayState) => {\n\n    let q = low,\n        i;\n\n    /*This for loop iterates the length of the array to be sorted \n      and will be comparing eahc element to the high\n    */\n    for (i = low; i < high; i++) {\n\n        if (arr[i] < arr[high]) {\n\n            setIndex(i);\n            setFollowingIndex(high);\n\n            await swap(arr, i, q);\n            q++;\n\n            const newQuickArray = arr.slice(0);\n            setArrayState(newQuickArray);\n        }\n    }\n    await swap(arr, i, q);\n    return q;\n};\n\n/* This function recursively performs a quicksort */\nlet quickSort = async (arr, low, high, setIndex, setFollowingIndex, setArrayState) => {\n\n    if (low < high) {\n\n        //Determine the pivot point for the merge sort\n        let pivot = await partition(arr, low, high, setIndex, setFollowingIndex, setArrayState);\n\n        //Recursively sort the left side here\n        await quickSort(arr, low, pivot - 1, setIndex, setFollowingIndex, setArrayState);\n\n        //Recursively sort the right side here\n        await quickSort(arr, pivot + 1, high, setIndex, setFollowingIndex, setArrayState);\n        return arr;\n    }\n};\n\n\nexport default async function QuickSort(\n\n    getArrayState, setArrayState, setIndex, setFollowingIndex, setDisable\n\n) {\n\n    let array = getArrayState();\n    if (sortValidation(array) === false) {\n        setDisable(true);\n        const length = array.length;\n\n        array = await quickSort(array, 0, length - 1, setIndex, setFollowingIndex, setArrayState);\n\n        //Update this new array to the screen\n        const newQuickArray = array.slice(0);\n        setArrayState(newQuickArray);\n\n        //Clear any colours off the screen \n        setIndex(null);\n        setFollowingIndex(null);\n\n\n        setDisable(false);\n    } else {\n        alert(\"Please Generate a new Array\\n as current is sorted\");\n    }\n\n\n}","import {sleep} from './Timer';\nimport timerScale from './TimerScale';\nimport sortValidation from './SortValidation';\n\n\n\n/*This function will act as the controller and perform the main sort */\nasync function heapSort(array, setArrayState, setIndex, setFollowingIndex) {\n    let size = array.length;\n\n    // build heapSort (rearrange array)\n    for (let i = Math.floor(size / 2 - 1); i >= 0; i--) {\n\n        await sleep(timerScale(array.length, 200));\n        setIndex(i);\n        setFollowingIndex(i - 1);\n\n\n        heapify(array, size, i, setArrayState, setIndex, setFollowingIndex);\n        await sleep(timerScale(array.length, 200));\n    }\n\n    //one by one extract an element from heapSort\n    for (let i = size - 1; i >= 0; i--) {\n\n        await sleep(timerScale(array.length, 200));\n        setIndex(i);\n        setFollowingIndex(i - 1);\n\n        // move current root to end\n        let temp = array[0];\n        array[0] = array[i];\n        array[i] = temp;\n\n        await sleep(timerScale(array.length, 200));\n        const newHeapArray = array.slice(0);\n        setArrayState(newHeapArray);\n\n        //call max heapify on the reduced heapSort\n        heapify(array, i, 0, setArrayState, setIndex, setFollowingIndex);\n\n    }\n}\n\n// to heapify a subtree rooted with node i which is an index in array[]\nasync function heapify(array, size, i, setArrayState, setIndex, setFollowingIndex) {\n\n\n    let max = i; // initialize max as root\n    let left = 2 * i + 1;\n    let right = 2 * i + 2;\n\n    // if left child is larger than root\n    if (left < size && array[left] > array[max]) {\n        max = left;\n    }\n\n\n\n    // if right child is larger than max\n    if (right < size && array[right] > array[max]) {\n        max = right;\n    }\n\n\n    // if max is not root\n    if (max !== i) {\n\n\n        // swap the elements here and update their colours\n        let temp = array[i];\n        array[i] = array[max];\n        array[max] = temp;\n\n\n        // recursively heapify the affected sub-tree\n        heapify(array, size, max, setArrayState, setIndex, setFollowingIndex);\n\n    }\n}\n\n/*This function will be the controller and commence the heapsort */\nexport default async function HeapSort(getArrayState, setArrayState, setIndex,\n    setFollowingIndex, setDisable) {\n\n\n    let array = getArrayState();\n\n    //Continue the sort if its not sorted already\n    if (sortValidation(array) === false) {\n\n        setDisable(true);\n\n\n        //Perform the sort from the sorting function \n        await heapSort(array, setArrayState, setIndex, setFollowingIndex);\n\n        //Update this new array to the screen\n        const newHeapArray = array.slice(0);\n        setArrayState(newHeapArray);\n\n        //Clear any colours off the screen \n        setIndex(null);\n        setFollowingIndex(null);\n\n        setDisable(false);\n\n    } else {\n        alert(\"Please Generate a new Array\\n as current is sorted\");\n    }\n\n\n};","import React, {useState, useEffect} from 'react'; \nimport './css/index.css';\nimport './css/App.css'; \nimport Header from './Header/Header'; \nimport Body from './Body/Body'; \nimport bubbleSort from './Sorting/Bubble'; \nimport MergeSort from './Sorting/Merge'; \nimport QuickSort from './Sorting/Quick'; \nimport HeapSort from './Sorting/Heap'; \n\n\n/*Function will generate some random numbers between certain ranges*/ \nexport function randomInteger(min, max) { \n  return Math.floor(Math.random() * (max - min + 1)) + min; \n}\n\nfunction App() {\n\n  //Set the use state here with an intial value of 50 since it will be the minimum # of bars \n  let [sliderState, sliderValue] = useState(15); \n  const [array, setRandomArray] = useState([]);\n  \n  //Use states for the sorting methods\n  const [activeIndex, setActiveIndex] = useState(null); \n  const [nextIndex, setNextIndex] = useState(null); \n  const [disableOptions, setBool ] = useState(null); \n\n\n   //UseEffect everytime the state of the slider, meaning we have a new value here \n    /*useEffect will be ran when the state of the slider changes */\n    useEffect(() => {   \n        \n      //Create the random array and load it with the values needed\n      const generatedArray = [sliderState]; \n\n      for (let i = 0; i < sliderState; i++) { \n          generatedArray[i] = randomInteger(40, 850); \n      }\n\n      setRandomArray(generatedArray); \n      console.log(generatedArray); \n\n  },[sliderState]); //Depends on the sliderState \n\n\n/*This function will be used to control this state from the app */\n  function ControlSliderState(value) { \n\n    //sliderState = value;\n    sliderValue(value); \n\n  }\n\n  /* Various setters to control the state from the \n  main App controller; getters optional here*/ \n\n  function setArrayState(newGeneration) { \n    setRandomArray(newGeneration); \n  }\n\n  function getArrayState() { \n    return array; \n  }\n\n  function getSliderState() { \n    return sliderState; \n  }\n\n  function setIndex(index) { \n    setActiveIndex(index); \n}\n\n  function getIndex() { \n    return activeIndex; \n  }\n\n  function setFollowingIndex(index) { \n    setNextIndex(index); \n  }\n\n  function getFollowingIndex() {\n    return nextIndex;\n  }\n\n\n  function setDisable(boolean) { \n    setBool(boolean); \n  }\n\n  function getDisableValue() { \n    return disableOptions; \n  }\n\n\n  return (\n    <div className=\"App\"> \n\n      \n      {/*This is the header of the program which acts as the controller*/}\n      <Header\n        \n        ControlSliderState={ControlSliderState}\n        getSliderState={getSliderState}\n        setArrayState={setArrayState}\n        getArrayState={getArrayState}\n        bubbleSort={bubbleSort}\n        MergeSort={MergeSort}\n        QuickSort={QuickSort}\n        HeapSort={HeapSort}\n        setIndex={setIndex}\n        setFollowingIndex={setFollowingIndex}\n        setDisable={setDisable}\n        getDisableValue={getDisableValue}\n\n\n      />\n\n      {/*This is the body where we are able to see the bars and such*/}\n      <Body\n\n        data={array}\n        //setIndex={setIndex}\n        getIndex={getIndex}\n        //setFollowingIndex={setFollowingIndex}\n        getFollowingIndex={getFollowingIndex}\n       // setDisable={setDisable}\n        //getDisableValue={getDisableValue}\n\n      />\n      \n\n     \n    </div>\n    \n  );\n}\n\nexport default App;\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './css/index.css';\nimport App from './App';\n\n\n/*\nThe root here is referencing the root class which we will use to add the elements to the react page \nparams are : ( what we want to render, what we want to render it too )\n*/ \nReactDOM.render(<App/>,  document.getElementById('root'));\n\n"],"sourceRoot":""}